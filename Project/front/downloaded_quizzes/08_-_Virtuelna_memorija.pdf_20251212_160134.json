{
  "chapters": [
    {
      "chapter_number": 1,
      "content_preview": "--- Page 1 ---\nOPERATIVNI SISTEMI\nVirtuelna memorijaSlajdovi sukreirani naosnovu knjige \u201cOperativni sistemi , principi unutra \u0161nje organizacije i diza...",
      "questions": [
        {
          "question_data": {
            "correct_answer": "A) William Stallings",
            "explanation": "Page 1 explicitly states the slides are based on the book 'Operativni sistemi...' by William Stallings (CET, 2013). The distractors are notable computer scientists unrelated to this source.",
            "options": [
              "A) William Stallings",
              "B) Andrew Tanenbaum",
              "C) Alan Turing",
              "D) Dennis Ritchie"
            ],
            "question": "Who is the author of the book referenced on Page 1?"
          },
          "solo_level": "unistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Operating Systems, Virtual Memory, William Stallings",
            "explanation": "Page 1 specifically mentions 'OPERATIVNI SISTEMI' (Operating Systems), 'Virtuelna memorija' (Virtual Memory), and the book author William Stallings. Other options include incorrect details like '8th edition', 'Hardware Architecture', or 'Network Security', which aren't present.",
            "options": [
              "A) Operating Systems, Virtual Memory, William Stallings",
              "B) Virtual Memory, CET Belgrade, 8th edition",
              "C) William Stallings, 2013, Hardware Architecture",
              "D) CET, 7th edition, Network Security"
            ],
            "question": "According to Page 1, which three items are explicitly mentioned?"
          },
          "solo_level": "multistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Key OS concept covered in the textbook",
            "explanation": "Virtual Memory is presented as a core operating system concept within the textbook's framework. The slides (derived from Stallings' OS textbook) position it as an integral part of OS design, showing how memory management functions within the broader OS structure.",
            "options": [
              "A) Key OS concept covered in the textbook",
              "B) Hardware component independent of OS principles",
              "C) Standalone topic not addressed in the textbook",
              "D) Separate field unrelated to OS design"
            ],
            "question": "How does Virtual Memory relate to Operating Systems per the textbook on Page 1?"
          },
          "solo_level": "relational"
        },
        {
          "question_data": {
            "correct_answer": "A) Implement infinite scrolling to load content on demand",
            "explanation": "Infinite scrolling mirrors virtual memory's demand paging: both load resources only when needed. Options B-C-D address security/performance but don't generalize memory management principles to new domains.",
            "options": [
              "A) Implement infinite scrolling to load content on demand",
              "B) Use cookies to track user sessions",
              "C) Encrypt data transmissions via HTTPS",
              "D) Compress images for faster initial load"
            ],
            "question": "How could virtual memory principles be applied to optimize a web application's resource loading?"
          },
          "solo_level": "extended_abstract"
        }
      ],
      "title": "--- Page 1 ---"
    },
    {
      "chapter_number": 2,
      "content_preview": "--- Page 3 ---\nKarakteristike upravljanja memorijom\n\uf0a8Memorijske reference su logi\u010dke adrese koje \nse dinami \u010dki prevode u fizi\u010dke adrese u toku \nizvr\u0161...",
      "questions": [
        {
          "question_data": {
            "correct_answer": "A) Logical addresses",
            "explanation": "Page 3 explicitly states: 'Memorijske reference su logi\u010dke adrese koje se dinami\u010dki prevode u fizi\u010dke adrese u toku izvr\u0161avanja' (Memory references are logical addresses that are dynamically translated to physical addresses during execution).",
            "options": [
              "A) Logical addresses",
              "B) Physical addresses",
              "C) Virtual addresses",
              "D) Static addresses"
            ],
            "question": "According to Page 3, which addresses are dynamically translated to physical addresses during execution?"
          },
          "solo_level": "unistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) They allow only required process parts to be loaded in memory during execution",
            "explanation": "Dynamic address translation (logical\u2192physical mapping) enables flexible placement, while non-contiguous allocation permits splitting processes",
            "options": [
              "A) They allow only required process parts to be loaded in memory during execution",
              "B) They ensure processes execute faster by avoiding physical memory entirely",
              "C) They force all process segments to occupy contiguous memory blocks for simplicity",
              "D) They eliminate memory fragmentation by using fixed-size partitions exclusively"
            ],
            "question": "How do dynamic address translation and non-contiguous allocation work together to enable efficient memory management?"
          },
          "solo_level": "relational"
        }
      ],
      "title": "--- Page 3 ---"
    },
    {
      "chapter_number": 3,
      "content_preview": "--- Page 8 ---\nPrednosti nove strategije \nupravljanja memorijom\n\uf0a8Deo memorije mo\u017ee biti \ndeljen od strane vi\u0161e procesa\n\uf0a4Ista stranica se mapira u \nvir...",
      "questions": [
        {
          "question_data": {
            "correct_answer": "A) System libraries",
            "explanation": "Page 8 explicitly states that system libraries are one application where memory can be shared among multiple processes, under the 'Primenjuje se za' section.",
            "options": [
              "A) System libraries",
              "B) CPU registers",
              "C) Hard disk partitions",
              "D) Network bandwidth"
            ],
            "question": "What can be shared by multiple processes according to the new memory management strategy on Page 8?"
          },
          "solo_level": "unistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Shared memory for processes, same page mapping, applications like system libraries/IPC/code sharing",
            "explanation": "Page 8 explicitly lists three benefits: (1) Memory sharing by multiple processes, (2) Mapping identical pages to multiple processes' virtual space, and (3) Applications including shared system libraries, IPC via shared memory, and code sharing across process instances",
            "options": [
              "A) Shared memory for processes, same page mapping, applications like system libraries/IPC/code sharing",
              "B) Resident set tracking, page status indication, faster process execution",
              "C) Virtual space optimization, reduced power consumption, hardware compatibility",
              "D) Improved security, automatic backups, simplified process scheduling"
            ],
            "question": "Which option lists THREE benefits of the new memory management strategy described on Page 8?"
          },
          "solo_level": "multistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Resident set indicators track which shared pages are currently loaded in memory",
            "explanation": "The resident set's page indicators (Page 9) allow the system to manage shared memory efficiently by tracking which pages are physically present. This enables multiple processes to safely access the same shared pages (Page 8) without duplication, supporting shared libraries, IPC, and code reuse.",
            "options": [
              "A) Resident set indicators track which shared pages are currently loaded in memory",
              "B) Resident sets prevent processes from accessing shared system libraries",
              "C) Resident sets allocate new memory for each shared page access",
              "D) Resident sets restrict shared memory access to only one process"
            ],
            "question": "How does the resident set (Page 9) enable the memory-sharing strategies described on Page 8?"
          },
          "solo_level": "relational"
        },
        {
          "question_data": {
            "correct_answer": "A) Sharing cached assets across tabs via mapped pages",
            "explanation": "The strategy allows identical resources (e.g., cached scripts/images) to be mapped into multiple tabs' virtual memory, reducing duplication\u2014similar to how system libraries are shared among processes. Other options involve isolation or prioritization, not direct sharing.",
            "options": [
              "A) Sharing cached assets across tabs via mapped pages",
              "B) Isolating each tab's memory completely for security",
              "C) Compressing memory when multiple tabs are inactive",
              "D) Prioritizing memory allocation to the active tab only"
            ],
            "question": "How might the memory management strategy from page 8 optimize resource usage in a web browser's tab system?"
          },
          "solo_level": "extended_abstract"
        }
      ],
      "title": "--- Page 8 ---"
    },
    {
      "chapter_number": 4,
      "content_preview": "--- Page 10 ---\nIzvr\u0161avanje procesa\n\uf0a8Ako se pri izvr\u0161avanju procesa referencira \nstranica koja je u glavnoj memoriji, pristupa se \ntra\u017eenoj lokaciji i...",
      "questions": [
        {
          "question_data": {
            "correct_answer": "A) Accesses the requested location and continues execution",
            "explanation": "Page 10 explicitly states that when a referenced page is already in main memory, the system 'pristupa se tra\u017eenoj lokaciji i nastavlja izvr\u0161avanje' (accesses the requested location and continues execution)",
            "options": [
              "A) Accesses the requested location and continues execution",
              "B) Triggers a page fault interrupt",
              "C) Moves the page from disk to memory",
              "D) Pauses execution until memory is freed"
            ],
            "question": "According to Page 10, what happens when a process references a page that IS in main memory?"
          },
          "solo_level": "unistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Page 10 shows normal execution, while page 11 introduces page faults requiring special handling",
            "explanation": "Page 10 describes standard execution when a page is in memory (direct access), while page 11 introduces the problem case (page not in memory) that creates a page fault",
            "options": [
              "A) Page 10 shows normal execution, while page 11 introduces page faults requiring special handling",
              "B) Page 10 handles disk storage, while page 11 manages CPU operations",
              "C) Both pages describe identical memory access scenarios",
              "D) Page 11 terminates processes that page 10 couldn't resolve"
            ],
            "question": "How do the scenarios on pages 10 and 11 relate in process execution?"
          },
          "solo_level": "relational"
        },
        {
          "question_data": {
            "correct_answer": "C) Fetch the data from a slower secondary storage (e.g., database)",
            "explanation": "This transfers page-fault logic (fetching missing pages from disk) to caching systems",
            "options": [
              "A) Halt processing until cache is manually updated",
              "B) Ignore the request and continue execution",
              "C) Fetch the data from a slower secondary storage (e.g., database)",
              "D) Immediately terminate the process with an error"
            ],
            "question": "Applying the memory page reference concept, how would a caching system handle a request for data not in its cache?"
          },
          "solo_level": "extended_abstract"
        }
      ],
      "title": "--- Page 10 ---"
    },
    {
      "chapter_number": 5,
      "content_preview": "--- Page 12 ---\nIzvr\u0161avanje procesa\n\uf0a8Ako se referencira stranica koja nije u glavnoj \nmemoriji\n\uf0a4To je gre\u0161ka stranice (eng. page fault )\n\uf0a4Hardver utvr...",
      "questions": [
        {
          "question_data": {
            "correct_answer": "A) Page fault",
            "explanation": "Na stranici 12 jasno stoji: 'Ako se referencira stranica koja nije u glavnoj memoriji, to je gre\u0161ka stranice (eng. page fault)'. Ostale opcije su pojmovi povezani s postupkom, ali ne definiraju samu gre\u0161ku.",
            "options": [
              "A) Page fault",
              "B) Invalid bit",
              "C) Prekid procesora",
              "D) Blokiran proces"
            ],
            "question": "\u0160ta se naziva gre\u0161kom kada se referencira stranica koja nije u glavnoj memoriji?"
          },
          "solo_level": "unistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Invalid bit detected \u2192 OS requested \u2192 Process blocked \u2192 Disk request sent",
            "explanation": "Option A correctly lists 4 independent steps in order: hardware detects invalid bit (p12), OS request (p12), process blocked (p13), and disk request (p13). Other options either misorder steps or include invalid sequences (e.g., disk interrupt cannot occur before a disk request).",
            "options": [
              "A) Invalid bit detected \u2192 OS requested \u2192 Process blocked \u2192 Disk request sent",
              "B) Invalid bit detected \u2192 Disk interrupt \u2192 OS requested \u2192 Process blocked",
              "C) OS requested \u2192 Process blocked \u2192 Disk interrupt \u2192 Invalid bit detected",
              "D) Disk request sent \u2192 Process blocked \u2192 Invalid bit detected \u2192 OS requested"
            ],
            "question": "According to pages 12-13, which list describes *independent* steps in a page fault process?"
          },
          "solo_level": "multistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Hardware detects invalid bit \u2192 OS fetches page \u2192 process waits \u2192 disk loads page \u2192 process unblocks",
            "explanation": "The sequence starts with hardware detecting an invalid bit (page fault), triggering an OS request",
            "options": [
              "A) Hardware detects invalid bit \u2192 OS fetches page \u2192 process waits \u2192 disk loads page \u2192 process unblocks",
              "B) OS blocks process first \u2192 requests disk \u2192 hardware detects fault \u2192 page loads",
              "C) Disk interrupt triggers \u2192 OS fetches page \u2192 hardware validates bit \u2192 process resumes",
              "D) Process unblocks automatically \u2192 OS checks disk \u2192 hardware validates page"
            ],
            "question": "How does the page fault handling sequence ensure the process resumes correctly?"
          },
          "solo_level": "relational"
        },
        {
          "question_data": {
            "correct_answer": "A) Fetch missing data from main memory, stall CPU",
            "explanation": "Like page faults fetching from disk, cache misses require retrieving data from slower main memory (new context). The CPU stalls during this transfer, mirroring how processes are blocked during page faults. This demonstrates transfer of memory hierarchy principles to cache systems.",
            "options": [
              "A) Fetch missing data from main memory, stall CPU",
              "B) Invalidate entire cache and restart process",
              "C) Reload cache with random data while continuing execution",
              "D) Switch to a different process immediately"
            ],
            "question": "How might the page fault mechanism be applied in a CPU cache's handling of a cache miss?"
          },
          "solo_level": "extended_abstract"
        }
      ],
      "title": "--- Page 12 ---"
    },
    {
      "chapter_number": 6,
      "content_preview": "--- Page 21 ---\nPrincip lokalnosti\n\uf0a4Tokom du\u017eeg perioda menjaju se delovi procesa \nkoji se koriste\n\uf0a4U kratkom intervalu procesor uglavnom radi sa \nmal...",
      "questions": [
        {
          "question_data": {
            "correct_answer": "A) Works with small/limited set of addresses",
            "explanation": "Page 21 directly states: 'U kratkom intervalu procesor uglavnom radi sa malim i ograni\u010denim skupom adresa' (In a short interval, the processor mostly works with a small and limited set of addresses). Options B and C reference other pages/concepts, while D contradicts this statement.",
            "options": [
              "A) Works with small/limited set of addresses",
              "B) Programs execute sequentially",
              "C) Process parts change frequently",
              "D) Accesses many different addresses"
            ],
            "question": "According to page 21, what does the principle of locality state about processor behavior in a short interval?"
          },
          "solo_level": "unistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Sequential execution and function localization ensure the processor mostly accesses a small address set in the short term",
            "explanation": "Page 21's observation that processors work with limited addresses in short intervals (locality) is directly caused by page 22's explanations: sequential execution (linear instruction flow) and function localization (limited variable access) naturally concentrate memory accesses to small, predicta...",
            "options": [
              "A) Sequential execution and function localization ensure the processor mostly accesses a small address set in the short term",
              "B) Branches and function calls expand the working address set to improve efficiency",
              "C) Hardware limitations force programs to prioritize specific data types first",
              "D) Long-term process changes prevent the processor from maintaining any address consistency"
            ],
            "question": "How do the reasons for locality (page 22) support the observed processor behavior described on page 21?"
          },
          "solo_level": "relational"
        },
        {
          "question_data": {
            "correct_answer": "A) People tend to travel within a limited local area most frequently",
            "explanation": "Just as processors access a small set of addresses (temporal/spatial locality), people exhibit locality by repeatedly accessing nearby locations (home/work/shops) in short intervals, minimizing long-distance travel unless necessary.",
            "options": [
              "A) People tend to travel within a limited local area most frequently",
              "B) Traffic flows randomly between all city zones equally",
              "C) Commuters prioritize exploring new distant areas daily",
              "D) Travel distance distribution remains uniform over time"
            ],
            "question": "How does the principle of locality apply to urban traffic patterns?"
          },
          "solo_level": "extended_abstract"
        }
      ],
      "title": "--- Page 21 ---"
    },
    {
      "chapter_number": 7,
      "content_preview": "--- Page 28 ---\nStruktura tabele stranica\n\uf0a8Pri izvr\u0161avanju procesa, naj\u010de\u0161\u0107e se po\u010detna \nadresa tabele stranica dr\u017ei u registru\n\uf0a4Ova adresa se \u010duva u ...",
      "questions": [
        {
          "question_data": {
            "correct_answer": "A) Process control block",
            "explanation": "According to page 28, the page table base address is stored in the process control block when not actively being used by the CPU. It is only loaded into a processor register during a context switch for execution.",
            "options": [
              "A) Process control block",
              "B) Processor register",
              "C) Main memory",
              "D) TLB (Translation Lookaside Buffer)"
            ],
            "question": "Where is the page table base address stored when not in use?"
          },
          "solo_level": "unistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Register storage, PCB storage, context switch loading, page indexing, frame-offset combination",
            "explanation": "Page 28 explicitly mentions: 1) Initial address stored in register/PCB 2) Context switch loading into register 3) Page number indexing 4) Frame-offset combination. Other options include concepts from later pages (B/D) or unrelated memory topics (C).",
            "options": [
              "A) Register storage, PCB storage, context switch loading, page indexing, frame-offset combination",
              "B) TLB lookup, page fault handling, frame allocation, protection bits",
              "C) Virtual addressing, segmentation, page replacement, working set",
              "D) DMA access, cache coherence, kernel mode, page coloring"
            ],
            "question": "Which list contains ONLY elements described on Page 28 regarding page table operations?"
          },
          "solo_level": "multistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Page number indexes page table (loaded from PCB) \u2192 retrieves frame \u2192 combines with offset",
            "explanation": "The page table's address (stored in PCB) is loaded into a processor register",
            "options": [
              "A) Page number indexes page table (loaded from PCB) \u2192 retrieves frame \u2192 combines with offset",
              "B) Offset indexes page table \u2192 retrieves page number \u2192 combines with frame",
              "C) Processor register directly provides frame number \u2192 combines with page number",
              "D) PCB uses offset to calculate physical address \u2192 stores result in page table"
            ],
            "question": "How do components of page table structure interact during virtual address translation?"
          },
          "solo_level": "relational"
        },
        {
          "question_data": {
            "correct_answer": "A) Mapping logical record keys to physical storage locations",
            "explanation": "Just as page tables map virtual page numbers to physical frames, database indexes map logical record identifiers (keys) to physical storage locations, demonstrating address translation principles in a new context.",
            "options": [
              "A) Mapping logical record keys to physical storage locations",
              "B) Optimizing SQL query execution order",
              "C) Managing transaction log write sequences",
              "D) Compressing redundant data blocks"
            ],
            "question": "How might the page table concept apply to a database system's index structure?"
          },
          "solo_level": "extended_abstract"
        }
      ],
      "title": "--- Page 28 ---"
    },
    {
      "chapter_number": 8,
      "content_preview": "--- Page 30 ---\nTLB Bafer\n\uf0a8Akose koristi virtuelna memorija , prisvakom\nreferenciranju podataka trebaju dvapristupa memoriji :\n\uf0a4Jedan da se preuzme st...",
      "questions": [
        {
          "question_data": {
            "correct_answer": "A) Translation Lookaside Buffer",
            "explanation": "The text explicitly states: 'Zove se Translation Lookaside Buffer (TLB)' under the TLB Bafer section. This is the only full name provided for TLB in the content, making option A the directly stated answer.",
            "options": [
              "A) Translation Lookaside Buffer",
              "B) Translation Lookup Buffer",
              "C) Table Lookaside Buffer",
              "D) Temporary Load Buffer"
            ],
            "question": "What does TLB stand for according to the content on page 30?"
          },
          "solo_level": "unistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Caches recent page table entries; Reduces memory accesses; Often multi-level",
            "explanation": "Page 30 explicitly states TLB caches recent page table entries, reduces double memory accesses caused by virtual memory, and mentions modern processors often implement multi-level TLBs. Other options include unsupported or contradictory claims.",
            "options": [
              "A) Caches recent page table entries; Reduces memory accesses; Often multi-level",
              "B) Stores entire page tables; Requires three memory accesses; Single-level only",
              "C) Replaces virtual memory; Slower than RAM; Uses software-only management",
              "D) Contains future page references; Eliminates physical addressing; Fixed-size buffer"
            ],
            "question": "According to Page 30, which features describe the Translation Lookaside Buffer (TLB)?"
          },
          "solo_level": "multistructural"
        },
        {
          "question_data": {
            "correct_answer": "A) Faster levels cache frequent entries, reducing slower page-table lookups",
            "explanation": "Multi-level TLBs use faster/smaller upper levels to cache frequent page-table entries (avoiding memory accesses), while slower/larger lower levels handle less frequent entries",
            "options": [
              "A) Faster levels cache frequent entries, reducing slower page-table lookups",
              "B) Larger levels prioritize rarely used entries for long-term storage",
              "C) Each level duplicates identical data to guarantee redundancy",
              "D) Lower levels operate at CPU clock speed to eliminate latency"
            ],
            "question": "How does the multi-level TLB hierarchy improve memory access efficiency in virtual memory systems?"
          },
          "solo_level": "relational"
        }
      ],
      "title": "--- Page 30 ---"
    }
  ],
  "metadata": {
    "config": {
      "distribution_mode": "auto",
      "question_mode": "auto",
      "solo_distribution": null,
      "total_questions": null,
      "use_smart_chunking": true
    },
    "distribution_mode": "auto",
    "filename": "08_-_Virtuelna_memorija.pdf",
    "generated_at": "2025-12-12T15:46:41.727068",
    "progress": {
      "chapters_completed": 8,
      "questions_generated": 27,
      "total_chapters": 10,
      "total_questions_target": 25
    },
    "question_mode": "auto",
    "total_chapters": 10,
    "total_questions": 27
  }
}